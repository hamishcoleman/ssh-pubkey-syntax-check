#!/usr/bin/env perl
use warnings;
use strict;
#
# Read as input a given known hosts file.
#
# Generate errors for any lines that have syntax errors
#

use MIME::Base64;

my $error = 0;
my $errorcount = 0;

sub error {
    my $error_new = shift;

    # TODO - make the new value the 'worst' of the two
    $error = $error_new;

    # TODO - make this look prettier;
    warn($ARGV,":",$.," ",@_,"\n");

    $errorcount++;
    if ($errorcount>10) {
        die("Too many errors, aborting remaining checks");
        exit $error;
    }
}

sub get_lvr {
    my ($binary) = @_;

    if (length($binary)<4) {
        # not even room for the length field
        return undef;
    }

    my ($len) = unpack('N',$binary);
    my ($val) = unpack('N/a',$binary);

    if ($len>(length($binary)+4)) {
        # this length value ran us off the end of the binary
        return undef;
    }

    return ($len,$val,substr($binary,$len+4));
}

sub check_key {
    my ($type,$encoded) = @_;

    # encoded is a base64 encoded array of len,val pairs (len is u32 value)

    # TODO
    # - use a better base64 function that actually reports errors
    # - if the len pointer is ever beyond the remaining length then we fail
    # - pair 1 looks like the same as the string type

    # for ecdsa-sha2-nistp256
    # - pair 2 is a second string value
    # - pair 3 is binary

    # for ssh-rsa
    # - pair 2 is "01 00 01"
    # - pair 3 is binary of length 0101
    # - pair 4 is ?
    # - pair 5 is ?
    # - pair 6 is ?

    if (!defined($encoded)) {
        error(1,"Base64 key missing");
        return undef;
    }

    my $binary = decode_base64($encoded);
    if (!defined($binary)) {
        error(1,"Base64 key decode error");
        return undef;
    }

    if (!length($binary)) {
        error(1,"key length error");
        return undef;
    }

    my ($len,$val);
    my @fields;
    while (length($binary)) {
        ($len,$val,$binary) = get_lvr($binary);
        if (!defined($len)) {
            error(1,"key structure length/val error");
            return undef;
        }
        push @fields,$val;
    }

    if ($type ne $fields[0]) {
        error(1,"Key type does not match encoded key");
        return undef;
    }
    # TODO - check field 0 against known key types
        
    # TODO - check other fields against correct values?

    # TODO - check number of fields found
    # - escda == 3?
    # - ssh-rsa == 6?

    return 1;
}

while(<>) {
    chomp;

# Lines starting with "#" and empty lines are ignored as comments.
    next if( m/^#/ );
    next if( m/^$/ );


# from sshd(8):
#  Each line in these files contains the following fields: markers
#  (optional), host-names, bits, exponent, modulus, comment.  The fields
#  are separated by spaces.
#
# This is partially inaccurate: markers,host-names,type,encoded,comment is the
# observed format

    my @f = split(/ /,$_);

# The marker is optional, but if it is present then it must be one of
# "@cert-authority", to indicate that the line contains a certification
# authority (CA) key, or "@revoked", to indicate that the key contained
# on the line is revoked and must not ever be accepted.  Only one marker
# should be used on a key line.

    if ($f[0] =~ m/^@/) {
        # TODO - should we confirm that it is one of the two allowed values?

        shift @f;
    }

    # We now know that there is no marker, so check for too many otherfields
    if (scalar(@f)>4) {
        error(1,"Too many fields");
    }

# Hashed hostnames start with a "|" character.  Only one hashed hostname
# may appear on a single line and none of the above negation or wildcard
# operators may be applied.

    if (scalar(@f)<3) {
        error(1,"Too few fields");

        # With not enough fields, we cannot really continue checking
        next;
    }

    if ($f[0] =~ m/^\|/) {
        # this is a hashed hostname

        if ($f[0] =~ m/[*?!,]/) {
            error(1,"Invalid operators in hashed hostname");
        }
    } else {
        my @hosts = split(/,/,$f[0]);

        # TODO - could split out the hostnames here and check they are sane

# A hostname or address may optionally be enclosed within "[" and "]"
# brackets then followed by ":" and a non-standard port number.

        for my $host (@hosts) {
            if ($host =~ m/\[/) {
                # if there is a square bracket anywhere in the hostname,
                # it must conform to the whole pattern
                
                if ($host !~ /^\[[^]]+]:\d+/) {
                    error(1,"Invalid non-standard port number");
                }
            }
        }
    }

         if ($f[1] =~ m/^ssh-dss$/) {
    } elsif ($f[1] =~ m/^ssh-rsa$/) {
    } elsif ($f[1] =~ m/^ecdsa-sha2-nistp256$/) {
    } else {
        error(1,"Unknown key type");
    }

    if (!check_key($f[1],$f[2])) {
        next;
    }

} continue {
    close ARGV if eof;
}

exit $error;
